// Code generated by entc, DO NOT EDIT.

package node

import (
	"entgo.io/ent/dialect/sql"
	"github.com/miscord-dev/toxfu/persistent/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int64) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int64) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int64) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int64) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int64) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int64) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int64) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int64) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int64) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// PublicKey applies equality check predicate on the "public_key" field. It's identical to PublicKeyEQ.
func PublicKey(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPublicKey), v))
	})
}

// PublicDiscoKey applies equality check predicate on the "public_disco_key" field. It's identical to PublicDiscoKeyEQ.
func PublicDiscoKey(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPublicDiscoKey), v))
	})
}

// HostName applies equality check predicate on the "host_name" field. It's identical to HostNameEQ.
func HostName(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHostName), v))
	})
}

// Os applies equality check predicate on the "os" field. It's identical to OsEQ.
func Os(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOs), v))
	})
}

// Goos applies equality check predicate on the "goos" field. It's identical to GoosEQ.
func Goos(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGoos), v))
	})
}

// Goarch applies equality check predicate on the "goarch" field. It's identical to GoarchEQ.
func Goarch(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGoarch), v))
	})
}

// LastUpdatedAt applies equality check predicate on the "last_updated_at" field. It's identical to LastUpdatedAtEQ.
func LastUpdatedAt(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastUpdatedAt), v))
	})
}

// PublicKeyEQ applies the EQ predicate on the "public_key" field.
func PublicKeyEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPublicKey), v))
	})
}

// PublicKeyNEQ applies the NEQ predicate on the "public_key" field.
func PublicKeyNEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPublicKey), v))
	})
}

// PublicKeyIn applies the In predicate on the "public_key" field.
func PublicKeyIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPublicKey), v...))
	})
}

// PublicKeyNotIn applies the NotIn predicate on the "public_key" field.
func PublicKeyNotIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPublicKey), v...))
	})
}

// PublicKeyGT applies the GT predicate on the "public_key" field.
func PublicKeyGT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPublicKey), v))
	})
}

// PublicKeyGTE applies the GTE predicate on the "public_key" field.
func PublicKeyGTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPublicKey), v))
	})
}

// PublicKeyLT applies the LT predicate on the "public_key" field.
func PublicKeyLT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPublicKey), v))
	})
}

// PublicKeyLTE applies the LTE predicate on the "public_key" field.
func PublicKeyLTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPublicKey), v))
	})
}

// PublicKeyContains applies the Contains predicate on the "public_key" field.
func PublicKeyContains(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPublicKey), v))
	})
}

// PublicKeyHasPrefix applies the HasPrefix predicate on the "public_key" field.
func PublicKeyHasPrefix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPublicKey), v))
	})
}

// PublicKeyHasSuffix applies the HasSuffix predicate on the "public_key" field.
func PublicKeyHasSuffix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPublicKey), v))
	})
}

// PublicKeyEqualFold applies the EqualFold predicate on the "public_key" field.
func PublicKeyEqualFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPublicKey), v))
	})
}

// PublicKeyContainsFold applies the ContainsFold predicate on the "public_key" field.
func PublicKeyContainsFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPublicKey), v))
	})
}

// PublicDiscoKeyEQ applies the EQ predicate on the "public_disco_key" field.
func PublicDiscoKeyEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyNEQ applies the NEQ predicate on the "public_disco_key" field.
func PublicDiscoKeyNEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyIn applies the In predicate on the "public_disco_key" field.
func PublicDiscoKeyIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPublicDiscoKey), v...))
	})
}

// PublicDiscoKeyNotIn applies the NotIn predicate on the "public_disco_key" field.
func PublicDiscoKeyNotIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPublicDiscoKey), v...))
	})
}

// PublicDiscoKeyGT applies the GT predicate on the "public_disco_key" field.
func PublicDiscoKeyGT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyGTE applies the GTE predicate on the "public_disco_key" field.
func PublicDiscoKeyGTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyLT applies the LT predicate on the "public_disco_key" field.
func PublicDiscoKeyLT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyLTE applies the LTE predicate on the "public_disco_key" field.
func PublicDiscoKeyLTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyContains applies the Contains predicate on the "public_disco_key" field.
func PublicDiscoKeyContains(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyHasPrefix applies the HasPrefix predicate on the "public_disco_key" field.
func PublicDiscoKeyHasPrefix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyHasSuffix applies the HasSuffix predicate on the "public_disco_key" field.
func PublicDiscoKeyHasSuffix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyEqualFold applies the EqualFold predicate on the "public_disco_key" field.
func PublicDiscoKeyEqualFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPublicDiscoKey), v))
	})
}

// PublicDiscoKeyContainsFold applies the ContainsFold predicate on the "public_disco_key" field.
func PublicDiscoKeyContainsFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPublicDiscoKey), v))
	})
}

// HostNameEQ applies the EQ predicate on the "host_name" field.
func HostNameEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHostName), v))
	})
}

// HostNameNEQ applies the NEQ predicate on the "host_name" field.
func HostNameNEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHostName), v))
	})
}

// HostNameIn applies the In predicate on the "host_name" field.
func HostNameIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHostName), v...))
	})
}

// HostNameNotIn applies the NotIn predicate on the "host_name" field.
func HostNameNotIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHostName), v...))
	})
}

// HostNameGT applies the GT predicate on the "host_name" field.
func HostNameGT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHostName), v))
	})
}

// HostNameGTE applies the GTE predicate on the "host_name" field.
func HostNameGTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHostName), v))
	})
}

// HostNameLT applies the LT predicate on the "host_name" field.
func HostNameLT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHostName), v))
	})
}

// HostNameLTE applies the LTE predicate on the "host_name" field.
func HostNameLTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHostName), v))
	})
}

// HostNameContains applies the Contains predicate on the "host_name" field.
func HostNameContains(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldHostName), v))
	})
}

// HostNameHasPrefix applies the HasPrefix predicate on the "host_name" field.
func HostNameHasPrefix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldHostName), v))
	})
}

// HostNameHasSuffix applies the HasSuffix predicate on the "host_name" field.
func HostNameHasSuffix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldHostName), v))
	})
}

// HostNameEqualFold applies the EqualFold predicate on the "host_name" field.
func HostNameEqualFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldHostName), v))
	})
}

// HostNameContainsFold applies the ContainsFold predicate on the "host_name" field.
func HostNameContainsFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldHostName), v))
	})
}

// OsEQ applies the EQ predicate on the "os" field.
func OsEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOs), v))
	})
}

// OsNEQ applies the NEQ predicate on the "os" field.
func OsNEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOs), v))
	})
}

// OsIn applies the In predicate on the "os" field.
func OsIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOs), v...))
	})
}

// OsNotIn applies the NotIn predicate on the "os" field.
func OsNotIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOs), v...))
	})
}

// OsGT applies the GT predicate on the "os" field.
func OsGT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOs), v))
	})
}

// OsGTE applies the GTE predicate on the "os" field.
func OsGTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOs), v))
	})
}

// OsLT applies the LT predicate on the "os" field.
func OsLT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOs), v))
	})
}

// OsLTE applies the LTE predicate on the "os" field.
func OsLTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOs), v))
	})
}

// OsContains applies the Contains predicate on the "os" field.
func OsContains(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldOs), v))
	})
}

// OsHasPrefix applies the HasPrefix predicate on the "os" field.
func OsHasPrefix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldOs), v))
	})
}

// OsHasSuffix applies the HasSuffix predicate on the "os" field.
func OsHasSuffix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldOs), v))
	})
}

// OsEqualFold applies the EqualFold predicate on the "os" field.
func OsEqualFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldOs), v))
	})
}

// OsContainsFold applies the ContainsFold predicate on the "os" field.
func OsContainsFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldOs), v))
	})
}

// GoosEQ applies the EQ predicate on the "goos" field.
func GoosEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGoos), v))
	})
}

// GoosNEQ applies the NEQ predicate on the "goos" field.
func GoosNEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGoos), v))
	})
}

// GoosIn applies the In predicate on the "goos" field.
func GoosIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGoos), v...))
	})
}

// GoosNotIn applies the NotIn predicate on the "goos" field.
func GoosNotIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGoos), v...))
	})
}

// GoosGT applies the GT predicate on the "goos" field.
func GoosGT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGoos), v))
	})
}

// GoosGTE applies the GTE predicate on the "goos" field.
func GoosGTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGoos), v))
	})
}

// GoosLT applies the LT predicate on the "goos" field.
func GoosLT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGoos), v))
	})
}

// GoosLTE applies the LTE predicate on the "goos" field.
func GoosLTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGoos), v))
	})
}

// GoosContains applies the Contains predicate on the "goos" field.
func GoosContains(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGoos), v))
	})
}

// GoosHasPrefix applies the HasPrefix predicate on the "goos" field.
func GoosHasPrefix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGoos), v))
	})
}

// GoosHasSuffix applies the HasSuffix predicate on the "goos" field.
func GoosHasSuffix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGoos), v))
	})
}

// GoosEqualFold applies the EqualFold predicate on the "goos" field.
func GoosEqualFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGoos), v))
	})
}

// GoosContainsFold applies the ContainsFold predicate on the "goos" field.
func GoosContainsFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGoos), v))
	})
}

// GoarchEQ applies the EQ predicate on the "goarch" field.
func GoarchEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGoarch), v))
	})
}

// GoarchNEQ applies the NEQ predicate on the "goarch" field.
func GoarchNEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGoarch), v))
	})
}

// GoarchIn applies the In predicate on the "goarch" field.
func GoarchIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGoarch), v...))
	})
}

// GoarchNotIn applies the NotIn predicate on the "goarch" field.
func GoarchNotIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGoarch), v...))
	})
}

// GoarchGT applies the GT predicate on the "goarch" field.
func GoarchGT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGoarch), v))
	})
}

// GoarchGTE applies the GTE predicate on the "goarch" field.
func GoarchGTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGoarch), v))
	})
}

// GoarchLT applies the LT predicate on the "goarch" field.
func GoarchLT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGoarch), v))
	})
}

// GoarchLTE applies the LTE predicate on the "goarch" field.
func GoarchLTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGoarch), v))
	})
}

// GoarchContains applies the Contains predicate on the "goarch" field.
func GoarchContains(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGoarch), v))
	})
}

// GoarchHasPrefix applies the HasPrefix predicate on the "goarch" field.
func GoarchHasPrefix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGoarch), v))
	})
}

// GoarchHasSuffix applies the HasSuffix predicate on the "goarch" field.
func GoarchHasSuffix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGoarch), v))
	})
}

// GoarchEqualFold applies the EqualFold predicate on the "goarch" field.
func GoarchEqualFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGoarch), v))
	})
}

// GoarchContainsFold applies the ContainsFold predicate on the "goarch" field.
func GoarchContainsFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGoarch), v))
	})
}

// LastUpdatedAtEQ applies the EQ predicate on the "last_updated_at" field.
func LastUpdatedAtEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtNEQ applies the NEQ predicate on the "last_updated_at" field.
func LastUpdatedAtNEQ(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtIn applies the In predicate on the "last_updated_at" field.
func LastUpdatedAtIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastUpdatedAt), v...))
	})
}

// LastUpdatedAtNotIn applies the NotIn predicate on the "last_updated_at" field.
func LastUpdatedAtNotIn(vs ...string) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastUpdatedAt), v...))
	})
}

// LastUpdatedAtGT applies the GT predicate on the "last_updated_at" field.
func LastUpdatedAtGT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtGTE applies the GTE predicate on the "last_updated_at" field.
func LastUpdatedAtGTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtLT applies the LT predicate on the "last_updated_at" field.
func LastUpdatedAtLT(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtLTE applies the LTE predicate on the "last_updated_at" field.
func LastUpdatedAtLTE(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtContains applies the Contains predicate on the "last_updated_at" field.
func LastUpdatedAtContains(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtHasPrefix applies the HasPrefix predicate on the "last_updated_at" field.
func LastUpdatedAtHasPrefix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtHasSuffix applies the HasSuffix predicate on the "last_updated_at" field.
func LastUpdatedAtHasSuffix(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtEqualFold applies the EqualFold predicate on the "last_updated_at" field.
func LastUpdatedAtEqualFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLastUpdatedAt), v))
	})
}

// LastUpdatedAtContainsFold applies the ContainsFold predicate on the "last_updated_at" field.
func LastUpdatedAtContainsFold(v string) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLastUpdatedAt), v))
	})
}

// StateEQ applies the EQ predicate on the "state" field.
func StateEQ(v State) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldState), v))
	})
}

// StateNEQ applies the NEQ predicate on the "state" field.
func StateNEQ(v State) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldState), v))
	})
}

// StateIn applies the In predicate on the "state" field.
func StateIn(vs ...State) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldState), v...))
	})
}

// StateNotIn applies the NotIn predicate on the "state" field.
func StateNotIn(vs ...State) predicate.Node {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Node(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldState), v...))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Node) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Node) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Node) predicate.Node {
	return predicate.Node(func(s *sql.Selector) {
		p(s.Not())
	})
}
